<!doctype html>
<html>
<head>
    <link rel="stylesheet" href="alg.css" />
    <script src="https://kit.fontawesome.com/c69157b4d5.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="module">
    import renderMathInElement from "https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.mjs";
    renderMathInElement(document.body,
              { fleqn: true,
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ]
              }
            );
    </script>
</head>
<body>

    <h1>The Stigma of Sigma Algebras</h1>

<div>
$M(X)$ &ndash;
<em>countably additive measures</em>
on the
<em>$\sigma$-algebra</em>
generated by the
<em>open sets</em>
of the
<em>topology</em>
on the set $X$.
</div>

<div>
Topology &ndash; a study of the word &ldquo;near&rdquo;.
</div>

<div>
A topology on a set is a collection of <em>open</em> subsets closed under finite
intersection and arbitrary union.
</div>

<div>
A definition of &ldquo;near&rdquo; only a mathematician could love.
</div>

<div>
Algebra (of sets) &ndash; a study of the words &ldquo;not&rdquo; and &ldquo;or&rdquo;
</div>

<div>
An algebra is a collection of subsets (including the empty set) closed under complement and union.
</div>

<div>
Algebras are closed under intersection (&ldquo;and&rdquo;) by De Morgans's laws.
</div>

<div>
Measure &ndash; a study of the word &ldquo;count&rdquo;.
</div>

<div>
A <em>measure</em> satisfies $\mu(A\cup B) = \mu(A) + \mu(B) - \mu(A\cap B)$ and $\mu(\emptyset) = 0$.
</div>

<div>
Measures don't double count. Note $\mu(A\cup B) = \mu(A) + \mu(B)$ if $A$ and $B$ are <em>disjoint</em>
($A\cap B = \emptyset$).
</div>

<div>
A <em>countably additive measure</em> satisfies
$\mu(\bigcup\{A_i\mid i\in\mathbb{N}\}) = \sum\{\mu(A_i)\mid i\in\mathbb{N}\}$
if $\{A_i\}$ are pairwise disjoint.
</div>

<div>
Riesz Representation Theorem: If $X$ is a compact Hausdorff space then $M(X) \cong C(X)^*$.
</div>

<div>
$C(X)^*$ &ndash; continuous linear functionals on $C(X)$.
</div>

<div>
Compact &ndash; the next best thing to being finite.
</div>

<div>
A set is <em>compact</em> if every open covering contains a finite subcovering.
</div>

<div>
A definition only a mathematician could love.
</div>

<div>
A topology is <em>Hausdorff</em> if for every point and every open set not
containing the point there exists an open set containing the point that
does not intersect the open set.
</div>

<div>
Sigma-algebras are great for proofs involving
$\lim\limits_{n\to\infty}\int f_n\,d\mu = \int\lim\limits_{n\to\infty} f_n\,d\mu$.
</div>
<div>
But they drag in a lot of machinery if you don't need to do that.
</div>

<div>
The proof is highly techical &ndash; 6 pages in Rudin's <em>Real and Complex Analysis</em>.
</div>

<div>
If $X$ is any set then $B(X)^* \cong ba(X)$.
</div>
<div>
$B(X)$ &ndash; bounded functions on $X$.
</div>
<div>
$ba(X)$ &ndash; finitely additive measures on $X$.
</div>
<div>
$\{\displaystyle\sum_i a_i 1_{A_i}\mid a_i\in\mathbb{R}, A_i\subseteq X\}$ is norm dense in $B(X)$.
</div>
<div>
If $\lambda\in ba(X)$ define $L(\sum_i a_i 1_{A_i}) = \sum_i a_i \lambda(A_i)$.
</div>
<div>
Well-defined since $\sum_i a_i 1_{A_i} = \sum_j b_j 1_{B_j}$ where $\{B_j\}$ are pairwise disjoint.
</div>
<div>
If $L\in B(X)^*$ define $\lambda(A) = L(1_A)$.
</div>
<div>
Norm preserving since ...
</div>
<div>
Same proof for $B(X,\mathcal{A})^* \cong ba(X,\mathcal{A})$ for any algebra $\mathcal{A}$.
</div>
<div>
Let $P\in ba(\Omega)$ be positive with $P(\Omega) = 1$.
The <em>conditional expectation</em> of $X$ given an algebra $\mathcal{A}$ is $Y = E[X|\mathcal{A}]$
where $Y$ is $\mathcal{A}$ measurable and $\int_A X\,dP = \int_A Y\,dP$ for all $A\in\mathcal{A}$.
</div>
<div>
This is equivalent to $(XP)|_\mathcal{A} = Y(P|_\mathcal{A})$ where
$ZP$ is the measure $(ZP)(A) = \int_A Z\,dP$ for $Z\in B(\Omega)$.
</div>

    <span>
        <button id='upArrow' type='button' onclick='upArrow()'><i class="fas fa-angle-up"></i></button>
    </span>
    <span>
        <button id='toggleInterval' type='button' onclick='toggleInterval()'>0</button>
    </span>
    <span>
        <button id='downArrow' type='button' onclick='downArrow()'><i class="fas fa-angle-down"></i></button>
    </span>

    <script language='javascript'>

        var vendors = ['-moz-', '-webkit-', '-o-', '-ms-', '-khtml-', ''];
        function toCamelCase(str) {
            return str.toLowerCase().replace(/(\-[a-z])/g, function ($1) {
                return $1.toUpperCase().replace('-', '');
            });
        };
        function setCss3Style(el, prop, val) {
            for (var i = 0, l = vendors.length; i < l; i++) {
                var p = toCamelCase(vendors[i] + prop);
                if (p in el.style)
                    el.style[p] = val;
            }
        };

        var length = 0;
        var counter = 0;
        var interval;
        var pause = 2000;

	function showElement(e) {
            e.style.visibility = 'visible';
            e.style.display = 'block';
            e.style.opacity = 1;
	    //e.style.transition = 'visibility 2s';
	    e.style.transition = 'opacity 2s linear';
            //setCss3Style(e, 'transition', 'visibility 2s');
            //setCss3Style(e, 'transition', 'opacity 2s linear');
            //e.scrollIntoView(false);
	}
        function hideElement(e) {
            e.style.visibility = 'hidden';
            e.style.display = 'none';
            e.style.opacity = 0;
	    //e.style.transition = 'visibility 2s';
	    e.style.transition = 'opacity 2s linear';
            //setCss3Style(e, 'transition', 'visibility 2s');
            //setCss3Style(e, 'transition', 'opacity 2s');
            //e.scrollIntoView(true);
        }

        function downArrow() {
            var pi = document.getElementById('div' + counter);
	    showElement(pi);
            //window.scrollBy(0, 30);
            if (counter < length - 1) {
                ++counter;
            }
            document.getElementById('toggleInterval').innerHTML = counter;
        }
        function upArrow() {
            document.getElementById('toggleInterval').innerHTML = counter;
            var pi = document.getElementById('div' + counter);
	    hideElement(pi);
            //window.scrollBy(0, -30);
            if (counter > 0)
                --counter;
            //window.scrollTo(0,document.body.scrollHeight);
        }

        function pauseInterval() {
            clearInterval(interval);
            document.getElementById('toggleInterval').innerHTML = counter;
            interval = null
        }
        function resumeInterval() {
            downArrow();
            interval = setInterval(downArrow, pause);
            document.getElementById('toggleInterval').innerHTML = counter;
        }
        function toggleInterval() {
            if (interval) {
                pauseInterval();
            }
            else {
                resumeInterval();
            }
        }

        var db = document.body;
        db.addEventListener('keydown', function (evt) {
            if (evt.keyCode == 39) { // right arrow
                downArrow();
                document.getElementById('count').innerHTML = counter;
            }
            if (evt.keyCode == 37 && counter > 0) { // left arrow
                upArrow();
            }
        });
        window.onload = function (e) {
            var p = document.getElementsByTagName('div');
            length = p.length;
            for (i = 0; i < length; ++i) {
                p[i].id = 'div' + i;
                p[i].style.visibility = 'hidden';
                p[i].style.display = 'none';
                p[i].style.opacity = 0;
            }
            resumeInterval();
        }
    </script>
</body>
</html>
